//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include "TriggerHandler.hh"

#include "ComponentOpenRave.hh"

// trigger user methods
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_CONSTRAINED_PATH(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_CLEAR()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_LOAD_FILE(const int &fileID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_LOAD_OBJECTRECOGNITION(const int &envID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_SAVE_FILE()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_CENTERED(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_NONE()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_SIMPLE(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_NORMAL_PATH()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_ADD(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_COMPUTEGRASPTABLE(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_DELETE(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_MOVE(const int &objectID, const double &x, const double &y, const double &z, const double &yaw, const double &pitch, const double &roll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLANNING_GRASPOBJ(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLANNING_RELEASEOBJ(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLAN_FURNITURE_MANIPUATION_TASK(const PLAN_FURNITURE_MANIPUATION_TASKType::modeType &mode, const unsigned int &furnitureIdentifier, const unsigned int &doorIdentifier, const double &openAmount)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLAN_PATH_TARGET_JOINT_ANGLES(const std::list<double> &angles)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLAN_PATH_TARGET_TCP_POSE(const double &x, const double &y, const double &z, const double &azimuth, const double &elevation, const double &roll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_SIMULATION_PLAN_ALL()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_SIMULATION_TEST_IK_ONLY()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
